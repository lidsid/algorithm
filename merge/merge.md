## 归并排序将两个的有序数列合并成一个有序数列，我们称之为"归并"。归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括"从上往下"和"从下往上"2种方式。![alt text][merge-image1]1. 从下往上的归并排序：> 将待排序的数列分成若干个长度为1的子数列，> 然后将这些数列两两合并；> 得到若干个长度为2的有序数列，再将这些数列两两合并；> 得到若干个长度为4的有序数列，再将它们两两合并；> 直接合并成一个数列为止。> 这样就得到了我们想要的排序结果。(参考下面的图片)2. 从上往下的归并排序：> 它与"从下往上"在排序上是反方向的。它基本包括3步：> ① 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2; > ② 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。> ③ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。下面的图片很清晰的反映了"从下往上"和"从上往下"的归并排序的区别。![alt text][merge-image2]从上往下的归并排序采用了递归的方式实现。它的原理非常简单，如下图：![alt text][merge-image3]## 算法原理归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。![alt text][merge-image4]可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。> 合并相邻有序子序列再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。![alt text][merge-image5]![alt text][merge-image6]## 时间复杂度归并排序的时间复杂度是O(N\*lgN)。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是O(N\*lgN)。## 稳定性归并排序是稳定的算法，它满足稳定算法的定义。算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！[merge-image1]: https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif "Merge Sort"[merge-image2]: https://images0.cnblogs.com/i/497634/201403/151853346211212.jpg[merge-image3]: https://images0.cnblogs.com/i/497634/201403/151855240908900.jpg[merge-image4]: https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png[merge-image5]: https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png[merge-image6]: https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194621308-588010220.png