## 选择排序选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。## 算法原理对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，得到最小记录并与第二个位置记录交换；重复该过程，知道进行比较的记录只剩下一个为止。## 时间复杂度从简单选择排序的过程来看，它最大的特点是交换移动数据次数相当少，这样就节约了相应的时间。分析它的时间复杂度发现，无论是最好最差情况，其比较次数都是一样多，第 i 趟排序需要进行 **n-i** 次关键字比较，此时需要比较次n-1+n-2+...+1，对于交换次数而言，当最好的时候，交换0次，最差的时候，也就是初始降时，交换次数为 n-1 次，基于最终的时间排序与交换次数总和，因此，总的时间复杂度依然为O(n<sup>2</sup>)## 稳定性选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。